---
layout: post
title: "객체지향 #7부 - 상속을 통한 코드 재사용"
description: >
  객체지향의 장점 중 하나인 코드 재사용에 기법 중 하나는 새로운 클래스를 추가하는 방법이다. 그 중 하나인 상속에 대해 살펴보자.
image: /assets/img/study/objectCover.jpg
related_posts:
  - _posts/study/object/2023-11-25-object_3.md
  - _posts/study/object/2023-12-07-object_4.md
  - _posts/study/object/2023-12-16-object_5.md
  
categories: [ study,object ]
---

* toc
{:toc}


**`상속`**은 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.<br>
상속을 통해 코드를 재사용하면서도 새로운 클래스를 빠르게 구현할 수 있다.<br>

## 재사용성 없는 중복 코드가 왜 싫어?

> 재사용성 없는 코드는 변경에 취약하다.<br> 
> **`Don't Repeat Yourself! (DRY 원칙)`**
{:.lead}

소프트웨어는 변경에 자유롭고 유연해야 한다. 이름 자체에 소프트가 들어가기도 한다.<br>
**`중복 코드`**는 코드 수정에 필요한 노력을 몇 배로 증가시킨다.<br>
뭐가 중복이지? 어디까지 퍼져있는거지? 뭐가 바뀌면 어떻게 바뀌는거지? 뭐가 영향을 받는거지? 등등<br>
중복 코드의 수정 방법은 새로운 중복 코드를 생성하는 것이다.<br>
점점 버그가 날 확률이 쌓여간다. 빨리 내 코드를 DRY 하게 수정해야 한다.<br>

> 여기서 **`중복`**이란 모양이 아니라 **`변경`**에 대한 반응이 어떠한가? 이다.
{:.note}

<br><br>

---

중복 코드를 제거하는 방법 중 하나로 상속을 사용한다.
그러나 이 상속은 **`결합도`**를 높인다. 어떤 자식 클래스를 만들 때 부모 클래스에 대한 전체 지식이 필요하기 때문이다.<br>
부모와 자식 클래스간에 강한 결합은 또 수정을 힘들게 하는 악순환을 만든다.<br>
<br>

> 재사용을 위해 상속을 사용할 경우,  **`super`** 라는 키워드를 최대한 배제하여야 한다. (결합도의 원인)<br>
{:.note}


## 취약한 기반 클래스 문제

super사용, 잘못된 상속 설계의 상태에서 재사용 목적으로 상속을 사용할 때 자식 클래스가 부모 클래스에 취약해지는 경우를 **`취약한 기반 클래스 문제`** 라는 명칭을 가진다.<br>

<br>
기반인 부모 클래스를 살펴보는 것 만으로 변경에 대한 확신을 가질 수 없고, 상속 받은 자식 클래스에 대한 전체 점검을 해야 하게 된다.<br>

<br>
<br>

#### 상속에 대한 4가지 취약한 기반 클래스 문제 예시

* 강하게 부모와 자식이 결합된다.
  * 상속은 자식이 부모 클래스의 세부사항에 의존하도록 하기 때문에 캡슐화를 약화시킨다. 
* 부모 클래스가 취약한 기반을 가지고 있으면 자식도 부실하다.
  * 상속받은 부모 클래스의 메서드가 자식 클랙스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
* 자식이 부모의 불필요한 인터페이스를 상속받을 수 있다.
  * 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
* 부모 클래스의 변경이 자식 클래스에 영향을 미친다.
  * 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다. 
  * 부모 클래스는 시간이 지남에 따라 변경될 수 있고, 자식 클래스는 부모 클래스의 변경에 영향을 받는다.

<br>

> 상속은 재사용성을 위해 캡슐화를 희생하는 선택이다.
{:.lead}


<br>
<br>


---


## 그럼 상속을 쓰지 말라는거야? 

아니다, **`추상화`**에 더 신경쓰면 리스크를 줄여서 쓸 수 있다.<br>
코드 중복을 제거하기 위해 상속을 도입할 때 따르는 원칙 **두 가지**는 아래와 같다.<br>

* 두 메서드가 유사해보이면 차이점을 추출해봐라. 
  * 다 추출해봤는데 동일해보이면 합칠 수 있다.
* 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라.
  * 부모 클래스의 구체 메서드를 자식으로 내리는 것 보다 자식 클래스의 추상 메서드를 부모로 올리는 것이 재사용성, 응집도에서 더 좋은 결과를 얻는다.

<br><br>

#### 두 가지 원칙 사용해 상속 보완하여 사용하기 (추상화)

중복 코드를 펼쳐놓고 차이점을 별도의 메서드로 추출하는 것이 시작이다.<br>
<br>

> 변하는 부분을 찾고 이를 캡슐화하라.
{:.lead}


~~~java
//file: `공통 추출 추상화 하고 싶은 두 객체`

// Rectangle 클래스
class Rectangle {
  String color;

  void draw() {
    System.out.println("색깔: " + color);
    System.out.println("사각형을 그립니다.");
  }
}

// Circle 클래스
class Circle {
  String color;

  void draw() {
    System.out.println("색깔: " + color);
    System.out.println("원을 그립니다.");
  }
}

~~~

<br>
위의 예시에서 Rectangle과 Circle 클래스의 draw 메서드는 유사하다.<br>
그러나 차이점이 있다면 사각형을 그리는지 원을 그리는지에 대한 차이점이다.<br>
이 두 객체를 추상화하여 **`차이점을 분리`**하면 공통된 부분인 색깔그리기가 나온다.<br>
추출된 색깔 그리기를 **`공통된 부분을 부모로 올려`** 부모 객체를 생성해주고, 다른 메서드를 각각 구현하면 아래 예시와 같다.<br>

~~~java
//file: `공통 추상화`

// 추상 클래스 Shape
abstract class Shape {
    String color;

    void draw() {
        System.out.println("색깔: " + color);
        drawShape();
    }

    abstract protected void drawShape();
}

// Rectangle 클래스는 Shape를 상속받음
class Rectangle extends Shape {
    @Override
    void drawShape() {
        System.out.println("사각형을 그립니다.");
    }
}

// Circle 클래스는 Shape를 상속받음
class Circle extends Shape {
    @Override
    void drawShape() {
        System.out.println("원을 그립니다.");
    }
}
~~~
<br>

이제 Rectangle과 Circle 클래스는 서로 다른 변경의 이유를 가지게 된다.<br>
놀랍게도 공통으로 추출된 Shape도 하나의 변경 이유만을 가지게 된다.<br>
부모 - 자식간의 추상화된 메서드에만 의존하게 설계가 바뀌었기 때문이다.<br>
또한 새로운 모양에 대한 추가도 쉽게 가능해졌다.<br>



<br>
<br>

---

## 아무리 고쳐도 리스크 있는 상속, 굳이 써야해?

상속에 대한 결합을 완벽히 피할 수 있는 방법은 없다. <br>
위의 두 가지 (차이점 추출 / 추상화) 기법을 사용해도 부모 클래스에서 인스턴스 변수 추가를 하면 자식은 모두 영향을 받는다.(생성자 변경 때문)<br>
중복 코드의 제거를 위해 일종의 리스크를 안고 상속을 사용하는 것이다.<br>
그래도 가급적 변화에 대한 전파 영향은 인스턴스 추가가 적기 때문에 기능에 대한 추상화를 진행하고 상속을 사용하는게 좋다.<br>
<br>

이런 리스크 없는 방법은 없을까? 있다.<br>
상속 이후에 많은 개발자들이 고민하여 내놓은 대답은 **`합성`**이다.<br>

<br>
<br>


---


## 합성이 상속보다 좋아?

