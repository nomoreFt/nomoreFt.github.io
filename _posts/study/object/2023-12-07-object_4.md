---
layout: post
title: "Object #4부 - "
description: >
  
image: /assets/img/study/objectCover.jpg
related_posts:

categories: [ study,object ]
---

* toc
{:toc}

객체지향에서의 추상화란 무엇인가? <br>
구체적인 구현에 의존하여 변경에 불안정한 설계를 쉽게 변하지 않는 불변성에 기대게 해주는 도구라고 생각한다.<br>
 <br>
저자는 이렇게 말했다.

> 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업이 추상화이다.

**`불필요한 정보`**는 무엇인가? 바로 **What**이 아닌, **How**이다.  세부적인 내용이 밖으로 드러나고 구체적인 구현에 의존하는 것이다.<br>
**`문제 해결에 필요한 핵심`**은 무엇인가? 프로그램이 해결하고 싶은 도메인의 문제를 객체끼리 메세지를 통해 협력관계를 맺고 해결하는 것이다.<br>
객체는 어떠한 책임을 부여받고, 그 책임을 수행하기 위해 필요한 상태를 가지고 자주적으로 행동한다.<br>


객체지향의 창시자라 불리는 `앨런 커티스 케이`는 콜로라도 대학에서 분자 생물학에 대한 학사를 받았다.<br>
객체가 자주적이고 살아있고, 필요한 기능만을 제공하며 협력하는 객체지향의 근간이 이해가 되기 시작한다.<br>
<br>

> 세포들의 협력관계에서 영감을 받은 그의 사상인 **메시징, 캡슐화, 동적 바인딩**은 객체지향의 핵심이라고 할 수 있다.<br>
{:.note}

우리는 복잡한 현실세계의 문제 해결을 위해 아주 작은 단위까지 나누고 쪼개는 **'분해'** 를 해야 한다.<br>
세포들의 작은 일들이 모여서 생명체의 기관이 동작하듯, 프로그램의 문제도 아주 작은 단위로 분해하는 것이 추상화의 시작인 것 이다.<br>
분해를 하면 복잡해보이는 문제도 비교적 단순해진다.<br>

![김현우_비순환그래프](https://github.com/nomoreFt/nomoreFt.github.io/assets/37995817/03cf8b8b-867c-409c-b723-de965727122d){:.centered}{: width="400"}
알고보면 OOP의 정수가 담겨있는 만화 일하는 세포들
{:.figcaption}


## 프로시저 추상화 vs 데이터 추상화

현대 프로그래밍 언어를 특징 짓는 두 가지 추상화 방법은 `프로시저 추상화`, `데이터 추상화` 이다.<br>

* 프로시저 추상화 : 소프트웨어가 `무엇을 해`야 하는지를 추상화
  * 기능 분해의 길
* 데이터 추상화 : 소프트웨어가 `무엇을 알아`야 하는지를 추상화
  * 데이터의 타입을 추상화 (추상 데이터 타입)
  * **데이터 중심의 프로시저 추상화 (우리가 배우고 있는 객체지향)**
  
시스템 분해의 시작은 이 추상화 방법들 중 한 가지 선택에서 시작된다. <br>
지금까지 우리가 배우고 있는 객체지향은 결국 **데이터 중심의 프로시저 추상화**다.
`역할과 책임을 수행하는 객체` 로 **추상화** 하고, 기능을 `협력하는 객체 공동체` 로 **분해**한다.

> 필요한 객체 식별, 협력관계 설정으로 기능 분해가 끝났다면<br>
> **(데이터 추상화 + 프로시저 추상화 = 클래스)** 클래스 단위로 시스템 분해를 진행한다.<br>
{:.note}


#### Q: 데이터를 중심으로 프로시저를 추상화하는 객체지향이 기능 분해 방법들 중 가장 효과적이라고 말하는 이유는 무엇일까?

먼저 객체지향이 아닌 방법에 대해 알아보자.<br>

* 전통적인 기능 분해 방법 (Top-Down 접근)
~~~text
- 직원의 급여를 계산한다.
1. 사용자로부터 소득세율을 입력받는다.
    1-1."세율을 입력하세요" 라는 문장을 화면에 출력한다.
    1-2.키보드를 통해 세율을 입력받는다.
2. 직원의 급여를 계산한다.
    2-1.전역 변수에 저장된 직원의 기본급 정보를 얻는다.
    2-2.급여를 계산한다.
3. 양식에 맞게 결과를 출력한다.
    3-1."이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.
~~~

일종의 책의 **목차**나 **매뉴얼**과 흡사하다.<br>
상위 기능을 생각하고 하위로 내려가면서 기능을 세분화하는 방법이다.<br>
이 기능을 분해하고 구체화하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다.<br>


#### 기능 위주 분해의 문제점

기본적으로 기능 분해는 결합도가 높아 변경에 취약하다.<br>

1. 시스템이 하나의 메인 함수(Top)으로 구성되어 있지 않다. 
   * 기능의 최 상단 (Top)이란 개념은 없다.
   * 변경되면서 여러 개의 동등한 수준의 함수 집합으로 성장하게 된다.
2. 기능 추가나 요구사항 변경으로 메인 함수를 빈번하게 수정해 코드를 추가할 때 리스크가 커진다.
   * 새로운 기능이 추가되면 정상인 메인부터 수정이 들어가야 한다.
   * 이미 정해진 탑다운 구조에 새로운 기능을 억지로 끼워넣어야 하는 상황이 된다.
3. 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
   * 비즈니스 로직과 사용자 인터페이스는 변경되는 빈도가 다르다. 변경 빈도는 사용자 인터페이스 >>> 비즈니스 로직
   * 사용자 인터페이스를 GUI로 변경 시, 강하게 결합되어 있기 때문에 전체 재설계가 필요하다.
4. 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시켜 유연성과 재사용성이 떨어진다.
   * 설계에서 실행 순서부터 정하기 때문에 what 보다 how 에 집중하게 만든다.
   * 기능 분해에서는 실행 순서나 조건, 반복 제어구조를 결정하지 않으면 진행이 불가능하기 때문이다.
5. 데이터 형식이 변경되면 파급효과가 크다.
   * 어떤 데이터를 어떤 분해된 기능이 사용하고 있는지 추적이 힘들다.
   * 한 데이터를 수정해도 다른 의도치 않은 기능에 영향을 미칠 수 있다.
   
> 변경에 대한 영향을 최소화하기 위해 영향을 받는부분 / 받지 않는 부분으로 분리하고<br>
> 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제해야 한다.<br>
> 하향식 설계는 이미 완성된 결과나 시스템에 대한 서술로는 훌륭한 기법이다.<br>
> 그러나 실제로 동작하는 커다란 소프트웨어를 설계하는데 적합한 방법이 아니다.<br>

{:.note}


### 정보은닉 & 모듈

앞서 하향식 설계에 대한 문제점에서 좋은 설계의 요건을 도출해낸 결과는 아래와 같다.

> 변경에 대한 영향을 최소화하기 위해 영향을 받는부분 / 받지 않는 부분으로 분리하고<br>
> 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제해야 한다.
{:.lead}

이는 외부에 감춰야 할 것에 따라 시스템을 **모듈 단위로 분할** 로 극복할 수 있다.<br>
변경될 가능성이 있는 것들을 내부로 감추고 외부에는 잘 정의되어 변경되지 않는 인터페이스만 공개하는 것이다.<br>
모듈 분할 단위에 대한 두 가지 고려사항은 아래와 같다.

* 복잡성
  * 외부에서 쓰기 편하게 추상화된 구조의 인터페이스를 공개한다.
* 변경 가능성
  * 변경될 가능성이 있는 것들을 내부로 잘 감춘다.

변경 가능성이 있어 모듈 내부로 감추고 싶은 것은 데이터, 복잡한 로직, 변경이 잦은 자료구조 등이다.<br>


#### 모듈단위 설계와 정보은닉의 효과

책에서 의미하는 모듈은 인스턴스화 되지 않은 클래스와 같은 개념이다.<br>
**EX) 회사에 속한 모든 직원을 가지고 있는 Employees 모듈**
{:.note}

모듈은 기능이 아닌, 변경의 정도에 따라 시스템을 분해한다.<br>
각각의 모듈들은 외부에 감춰야 하는 비밀과 관련도가 높은 데이터와 인터페이스의 집합이다.<br>


* 앞의 Top-down 설계와 다르게 변경의 영향이 모듈 내부에서만 영향을 미친다. 파급효과를 제어할 수 있게 된다.<br>
* 모듈 내부에 비즈니스 로직이 감춰져있기 때문에 사용자 인터페이스를 변경해도 영향을 받지 않는다.<br>
* 자바에서는 Package로 분리하게 되는데 동일한 이름에 대한 충돌을 방지해준다.


> 자연스럽게 모듈은 높은 응집도와 낮은 결합도를 가지게 된다.
> 모듈은 정보은닉을 통해 설계의 중심을 기능 -> 데이터로 가져왔다.
{:.lead}

**이를 통해 미지의 시스템 설계에서는 기능 중심적 분해보다 감춰야할 데이터를 중심으로 설계하는 것이 더 우수하다는 사실을 알 수 있었다.**
<br>
<br>

추가적으로 더 나아가야 할 점은 아직 모듈이 개별적인 인스턴스를 다루는 개념까지 발전하지 못했다는 점이다.<br>
개별적인 인스턴스를 다루기 위해서는 추상 데이터 타입도 고려하는 방식으로 나아가야 한다.<br>


### 추상 데이터 타입

> **type :** 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수
{:.lead}
















