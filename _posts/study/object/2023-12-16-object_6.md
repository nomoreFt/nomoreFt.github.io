---
layout: post
title: "Object #6부 - 의존성 원칙에 대한 구체적인 이야기"
description: >
  기존에 배웠던 의존성에 대한 원칙은 다소 추상적이다. 이번 장에서는 의존성 원칙을 구체적으로 살펴보고, 실질적인 예시를 통해 의존성을 어떻게 관리해야 하는지 알아보자.
image: /assets/img/study/objectCover.jpg
related_posts:
  - _posts/study/object/2023-11-25-object_3.md
  - _posts/study/object/2023-12-07-object_4.md
  - _posts/study/object/2023-12-16-object_5.md
  
categories: [ study,object ]
---

* toc
{:toc}



앞서 5장에 나온 기법들을 범용적인 언어로 묶어낸 원칙에 대해 알아보고 구체적인 의미를 파헤쳐보자.<br>


## 개방-폐쇄 원칙 (Open-Close-Principle)

> 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.<br>
> from **로버트 마틴**
{:.lead}

많은 이들이 들어는 봤을 유명한 원칙이다.<br>
그러나 열려있고 닫혀있고, 개방-폐쇄가 공존한다는 이 원칙을 보고 바로 온전히 이해하기는 쉽지 않다.<br>
<br>

* 확장에 대해 열려 있다 : 요구사항 변경에 맞게 새로운 **`동작`**을 추가해 기능을 확장할 수 있다.
* 수정에 대해 닫혀 있다 : 기존의 **`코드`**를 수정하지 않고도 기능을 추가하거나 변경할 수 있다.
<br><br>
OCP의 시작은 **`추상화`**에 있다.<br>
추상화를 통해 최대한 공통화 된 인터페이스를 만들어야 한다.<br>
불변성에 기대어야 한다. 다형성을 통해 최대한 런타임시에 추상화된 객체에 대한 의존으로 동작을 구현한다.<br>
이후 추상체에 대한 구현의 추가로 원하는 기능을 확장할 수 있다.<br><br>


~~~java
//file: `굿케이스`

public class EventPlanner {
    private EventPolicy policy;
    
    //EventPlanner가 특정 구현체에 의존하지 않고, 생성에 대한 책임을 외부에 위임한다.
    public EventPlanner(EventPolicy policy) {
        this.policy = policy;
    }
}
~~~
앞장에서 예시로 든 EventPlanner->EventPolicy
{:.figcaption}

<br>

여러 이벤트 전략들을 EventPolicy 타입으로 추상화 하고, 동작을 캡슐화해 간결하게 인터페이스를 정의했다.<br>
다양한 EventPolicy에 대한 확장은 EventPolicy를 구현하는 구현체를 추가함으로써 가능하다.<br>
추가시에 EventPolicy를 사용하고 있는 기존의 코드들에 대한 수정은 필요하지 않다.<br><br>

> **핵심은 추상체에 의존하여 컴파일 시점에 의존성을 고정하고 런타임 시점에 의존성을 변경하는 것이다.** 
{:.note}

<br><br>


## 생성-사용 분리

객체지향 설계에서 추상화에 의해 협력관계를 구성했다면, 내부에서 특정 구현체에 대한 생성을 하고 사용을 하지 말아야 한다.<br>
어떤 구현체에 대해 사용을 해야 할 지는 부탁하는 사람이 알아서 수행하는 객체는 사용을 하는 책임만 가지는 것이 좋다.<br>
위의 코드 예시에서 EventPlanner가 EventPolicy를 생성하지 말고, 외부에 EventPlanner에게 지시하는 객체가 생성해서 주입된 이벤트 정책을 실행시켜야 한다.<br>
그럼 EventPolicy는 추상체에만 의존하여 컴파일 시점에 의존성을 고정하고, 런타임 시점에 의존성을 변경할 수 있다.**`불변안정성이 생긴다.`**<br>

> 동일한 클래스 안에서 객체 생성과 사용을 하지 마라.<br>
> 특정한 구현체에 대한 생성은 외부의 지시자가 수행하도록 하라.
{:.note}


#### Q : 수행자에서 생성을 분리해서 지시자로 빼면, 지시자는 생성과 사용을 함께 가지게 되는데요?

그런 상황을 방지하기 위해서 지시자에도 생성과 사용을 분리해야 한다.<br>
지시자의 생성에 대한 책임을 분리하기 위해 도메인과 상관 없는 생성의 책임을 담당해주는 인공 클래스를 생성할 수 있다.<br>

> 적당한 책임을 가진 클래스를 찾지 못하거나 특정 도메인에 대한 책임 할당이 높은 응집도, 낮은 결합, 재사용성 등의 목적을 위반한다면 <br>
> 편의를 위해 인공적인 클래스를 생성해서 부여한다.<br>
> [GRASP] Pure Fabrication Pattern(순수한 가공물 패턴)
{:.lead}

<br><br>
우리는 반드시 도메인에 관련된 내용만을 협력 클래스로 만들어야 하는 것은 아니다.<br>
시스템 분해에는 도메인에 존재하는 개념을 협력 클래스로 만드는 **`표현적 분해`** 방법이 있고,<br>
실제 동작을 위해서 도메인 개념을 초월하는 **`행위적 분해`** 를 위한 기계적인 인공 개념의 클래스가 필요할 수 있다.<br>

<br><br>

---

#### 행위적 분해를 통해 나온 순수 인공 클래스란?


`EventPlanner`에게 지시하는 Client 객체에서는 특정 EventPolicy를 결합시켜 EventPlanner를 생성하게 된다.<br>
이럴 경우 Client객체에서 생성 책임과 사용 책임을 동시에 가지게 되는데, 생성 책임을 분리하기 위해 가공물인 `FACTORY 객체`를 생성해서 생성에 대한 책임을 넘긴다.<br>
Client의 생성 책임을 따로 넘길 도메인 개념과 객체가 없기 때문이다.

~~~java
//file: `Client-FACTORY`

public class EventPlannerFactory {

    public static EventPlanner createHolidayEventPlanner() {
        // 여기에서 필요한 EventPolicy 구현체들을 생성합니다.
        EventPolicy policy= new HolidayEventPolicy(...);
        
        // EventPlanner 객체를 생성하고, 정책 목록을 전달합니다.
        return new EventPlanner(policy);
    }
}

public class Client{
    private EventPlannerFactory factory;
    
    public Client(EventPlannerFactory factory){
        this.factory = factory;
    }
    
    public void calculateHolidaySomething(){
        EventPlanner planner = factory.createHolidayEventPlanner();
        // ...
    }
    
    
}
~~~

<br><br>


#### 순수 인공물 사용 사례는 아래와 같다.

* 데이터 접근 객체(Data Access Object, DAO): 데이터베이스와의 상호작용을 처리하는 클래스.
* 서비스 레이어(Service Layer): 비즈니스 로직을 처리하는 클래스.
* 유틸리티 클래스(Utility Class): 공통적으로 사용되는 기능을 제공하는 클래스.
* 팩토리 클래스(Factory Class): 객체 생성을 처리하는 클래스.
  * 객체 생성-사용 책임을 분리하기 위해 생성만을 책임지는 클래스를 생성한다.
* 검증 클래스(Validator Class): 검증을 처리하는 클래스.
  * 도메인 내부에 검증 로직이 함께 있으면 응집도가 낮아져 검증로직만을 위한 클래스를 생성한다.


<br><br>


---

