---
layout: post
title: "Object #6부 - 의존성 원칙에 대한 구체적인 이야기"
description: >
  기존에 배웠던 의존성에 대한 원칙은 다소 추상적이다. 이번 장에서는 의존성 원칙을 구체적으로 살펴보고, 실질적인 예시를 통해 의존성을 어떻게 관리해야 하는지 알아보자.
image: /assets/img/study/objectCover.jpg
related_posts:
  - _posts/study/object/2023-11-25-object_3.md
  - _posts/study/object/2023-12-07-object_4.md
  - _posts/study/object/2023-12-16-object_5.md
  
categories: [ study,object ]
---

* toc
{:toc}



앞서 5장에 나온 기법들을 범용적인 언어로 묶어낸 원칙에 대해 알아보고 구체적인 의미를 파헤쳐보자.<br>


## 개방-폐쇄 원칙 (Open-Close-Principle)

> 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다. -from **로버트 마틴**
{:.lead}

많은 이들이 들어는 봤을 유명한 원칙이다.<br>
그러나 열려있고 닫혀있고, 개방-폐쇄가 공존한다는 이 원칙을 보고 바로 온전히 이해하기는 쉽지 않다.<br>
<br>

* 확장에 대해 열려 있다 : 요구사항 변경에 맞게 새로운 **`동작`**을 추가해 기능을 확장할 수 있다.
* 수정에 대해 닫혀 있다 : 기존의 **`코드`**를 수정하지 않고도 기능을 추가하거나 변경할 수 있다.
<br><br>
OCP의 시작은 **`추상화`**에 있다.<br>
추상화를 통해 최대한 공통화 된 인터페이스를 만들어야 한다.<br>
불변성에 기대어야 한다. 다형성을 통해 최대한 런타임시에 추상화된 객체에 대한 의존으로 동작을 구현한다.<br>
이후 추상체에 대한 구현의 추가로 원하는 기능을 확장할 수 있다.<br><br>


~~~java
//file: `굿케이스`

public class EventPlanner {
    private EventPolicy policy;
    
    //EventPlanner가 특정 구현체에 의존하지 않고, 생성에 대한 책임을 외부에 위임한다.
    public EventPlanner(EventPolicy policy) {
        this.policy = policy;
    }
}
~~~
앞장에서 예시로 든 EventPlanner->EventPolicy
{:.figcaption}

<br>

여러 이벤트 전략들을 EventPolicy 타입으로 추상화 하고, 동작을 캡슐화해 간결하게 인터페이스를 정의했다.<br>
다양한 EventPolicy에 대한 확장은 EventPolicy를 구현하는 구현체를 추가함으로써 가능하다.<br>
추가시에 EventPolicy를 사용하고 있는 기존의 코드들에 대한 수정은 필요하지 않다.<br><br>

> **핵심은 추상체에 의존하여 컴파일 시점에 의존성을 고정하고 런타임 시점에 의존성을 변경하는 것이다.** 
{:.note}



